// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: task_series.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTasksInSeries = `-- name: CountTasksInSeries :one
SELECT COUNT(*) FROM tasks WHERE series_id = $1
`

func (q *Queries) CountTasksInSeries(ctx context.Context, seriesID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countTasksInSeries, seriesID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTaskSeries = `-- name: CreateTaskSeries :exec
INSERT INTO task_series (
    id, user_id, original_task_id, pattern, interval_value,
    end_date, due_date_calculation, is_active, created_at, updated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type CreateTaskSeriesParams struct {
	ID                 pgtype.UUID        `json:"id"`
	UserID             pgtype.UUID        `json:"user_id"`
	OriginalTaskID     pgtype.UUID        `json:"original_task_id"`
	Pattern            RecurrencePattern  `json:"pattern"`
	IntervalValue      int32              `json:"interval_value"`
	EndDate            pgtype.Timestamptz `json:"end_date"`
	DueDateCalculation DueDateCalculation `json:"due_date_calculation"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateTaskSeries(ctx context.Context, arg CreateTaskSeriesParams) error {
	_, err := q.db.Exec(ctx, createTaskSeries,
		arg.ID,
		arg.UserID,
		arg.OriginalTaskID,
		arg.Pattern,
		arg.IntervalValue,
		arg.EndDate,
		arg.DueDateCalculation,
		arg.IsActive,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deactivateTaskSeries = `-- name: DeactivateTaskSeries :exec
UPDATE task_series
SET is_active = false, updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type DeactivateTaskSeriesParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeactivateTaskSeries(ctx context.Context, arg DeactivateTaskSeriesParams) error {
	_, err := q.db.Exec(ctx, deactivateTaskSeries, arg.ID, arg.UserID)
	return err
}

const deleteTaskSeries = `-- name: DeleteTaskSeries :exec
DELETE FROM task_series
WHERE id = $1 AND user_id = $2
`

type DeleteTaskSeriesParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteTaskSeries(ctx context.Context, arg DeleteTaskSeriesParams) error {
	_, err := q.db.Exec(ctx, deleteTaskSeries, arg.ID, arg.UserID)
	return err
}

const getActiveTaskSeriesByUserID = `-- name: GetActiveTaskSeriesByUserID :many
SELECT id, user_id, original_task_id, pattern, interval_value,
       end_date, due_date_calculation, is_active, created_at, updated_at
FROM task_series
WHERE user_id = $1 AND is_active = true
ORDER BY created_at DESC
`

func (q *Queries) GetActiveTaskSeriesByUserID(ctx context.Context, userID pgtype.UUID) ([]TaskSeries, error) {
	rows, err := q.db.Query(ctx, getActiveTaskSeriesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskSeries{}
	for rows.Next() {
		var i TaskSeries
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OriginalTaskID,
			&i.Pattern,
			&i.IntervalValue,
			&i.EndDate,
			&i.DueDateCalculation,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskSeriesByID = `-- name: GetTaskSeriesByID :one
SELECT id, user_id, original_task_id, pattern, interval_value,
       end_date, due_date_calculation, is_active, created_at, updated_at
FROM task_series
WHERE id = $1
`

func (q *Queries) GetTaskSeriesByID(ctx context.Context, id pgtype.UUID) (TaskSeries, error) {
	row := q.db.QueryRow(ctx, getTaskSeriesByID, id)
	var i TaskSeries
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OriginalTaskID,
		&i.Pattern,
		&i.IntervalValue,
		&i.EndDate,
		&i.DueDateCalculation,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTaskSeriesByUserID = `-- name: GetTaskSeriesByUserID :many
SELECT id, user_id, original_task_id, pattern, interval_value,
       end_date, due_date_calculation, is_active, created_at, updated_at
FROM task_series
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetTaskSeriesByUserID(ctx context.Context, userID pgtype.UUID) ([]TaskSeries, error) {
	rows, err := q.db.Query(ctx, getTaskSeriesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TaskSeries{}
	for rows.Next() {
		var i TaskSeries
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.OriginalTaskID,
			&i.Pattern,
			&i.IntervalValue,
			&i.EndDate,
			&i.DueDateCalculation,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskSeriesWithLatestTask = `-- name: GetTaskSeriesWithLatestTask :one
SELECT
    ts.id, ts.user_id, ts.original_task_id, ts.pattern, ts.interval_value,
    ts.end_date, ts.due_date_calculation, ts.is_active, ts.created_at, ts.updated_at,
    t.id AS latest_task_id, t.title AS latest_task_title, t.status AS latest_task_status,
    t.due_date AS latest_task_due_date
FROM task_series ts
LEFT JOIN tasks t ON t.series_id = ts.id
WHERE ts.id = $1
ORDER BY t.created_at DESC
LIMIT 1
`

type GetTaskSeriesWithLatestTaskRow struct {
	ID                 pgtype.UUID        `json:"id"`
	UserID             pgtype.UUID        `json:"user_id"`
	OriginalTaskID     pgtype.UUID        `json:"original_task_id"`
	Pattern            RecurrencePattern  `json:"pattern"`
	IntervalValue      int32              `json:"interval_value"`
	EndDate            pgtype.Timestamptz `json:"end_date"`
	DueDateCalculation DueDateCalculation `json:"due_date_calculation"`
	IsActive           bool               `json:"is_active"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	LatestTaskID       pgtype.UUID        `json:"latest_task_id"`
	LatestTaskTitle    *string            `json:"latest_task_title"`
	LatestTaskStatus   NullTaskStatus     `json:"latest_task_status"`
	LatestTaskDueDate  pgtype.Timestamptz `json:"latest_task_due_date"`
}

func (q *Queries) GetTaskSeriesWithLatestTask(ctx context.Context, id pgtype.UUID) (GetTaskSeriesWithLatestTaskRow, error) {
	row := q.db.QueryRow(ctx, getTaskSeriesWithLatestTask, id)
	var i GetTaskSeriesWithLatestTaskRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.OriginalTaskID,
		&i.Pattern,
		&i.IntervalValue,
		&i.EndDate,
		&i.DueDateCalculation,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LatestTaskID,
		&i.LatestTaskTitle,
		&i.LatestTaskStatus,
		&i.LatestTaskDueDate,
	)
	return i, err
}

const getTasksBySeriesID = `-- name: GetTasksBySeriesID :many
SELECT id, user_id, title, description, status, user_priority,
       due_date, estimated_effort, category, context, related_people,
       priority_score, bump_count, created_at, updated_at, completed_at,
       series_id, parent_task_id
FROM tasks
WHERE series_id = $1
ORDER BY created_at ASC
`

type GetTasksBySeriesIDRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	SeriesID        pgtype.UUID        `json:"series_id"`
	ParentTaskID    pgtype.UUID        `json:"parent_task_id"`
}

func (q *Queries) GetTasksBySeriesID(ctx context.Context, seriesID pgtype.UUID) ([]GetTasksBySeriesIDRow, error) {
	rows, err := q.db.Query(ctx, getTasksBySeriesID, seriesID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTasksBySeriesIDRow{}
	for rows.Next() {
		var i GetTasksBySeriesIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.UserPriority,
			&i.DueDate,
			&i.EstimatedEffort,
			&i.Category,
			&i.Context,
			&i.RelatedPeople,
			&i.PriorityScore,
			&i.BumpCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.SeriesID,
			&i.ParentTaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTaskSeries = `-- name: UpdateTaskSeries :exec
UPDATE task_series
SET pattern = COALESCE($3, pattern),
    interval_value = COALESCE($4, interval_value),
    end_date = $5,
    due_date_calculation = COALESCE($6, due_date_calculation),
    is_active = COALESCE($7, is_active),
    updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type UpdateTaskSeriesParams struct {
	ID                 pgtype.UUID        `json:"id"`
	UserID             pgtype.UUID        `json:"user_id"`
	Pattern            RecurrencePattern  `json:"pattern"`
	IntervalValue      int32              `json:"interval_value"`
	EndDate            pgtype.Timestamptz `json:"end_date"`
	DueDateCalculation DueDateCalculation `json:"due_date_calculation"`
	IsActive           bool               `json:"is_active"`
}

func (q *Queries) UpdateTaskSeries(ctx context.Context, arg UpdateTaskSeriesParams) error {
	_, err := q.db.Exec(ctx, updateTaskSeries,
		arg.ID,
		arg.UserID,
		arg.Pattern,
		arg.IntervalValue,
		arg.EndDate,
		arg.DueDateCalculation,
		arg.IsActive,
	)
	return err
}
