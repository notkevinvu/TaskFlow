// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :exec

INSERT INTO tasks (
    id, user_id, title, description, status, user_priority,
    due_date, estimated_effort, category, context, related_people,
    priority_score, bump_count, created_at, updated_at, series_id, parent_task_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
`

type CreateTaskParams struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	SeriesID        pgtype.UUID        `json:"series_id"`
	ParentTaskID    pgtype.UUID        `json:"parent_task_id"`
}

// Task queries for sqlc code generation
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.Exec(ctx, createTask,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.UserPriority,
		arg.DueDate,
		arg.EstimatedEffort,
		arg.Category,
		arg.Context,
		arg.RelatedPeople,
		arg.PriorityScore,
		arg.BumpCount,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.SeriesID,
		arg.ParentTaskID,
	)
	return err
}

const deleteCategoryForUser = `-- name: DeleteCategoryForUser :exec
UPDATE tasks
SET category = NULL, updated_at = NOW()
WHERE user_id = $1 AND category = $2
`

type DeleteCategoryForUserParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	Category *string     `json:"category"`
}

// Apply to ALL tasks including completed ones - category management should be universal
func (q *Queries) DeleteCategoryForUser(ctx context.Context, arg DeleteCategoryForUserParams) error {
	_, err := q.db.Exec(ctx, deleteCategoryForUser, arg.UserID, arg.Category)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = $1 AND user_id = $2
`

type DeleteTaskParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteTask(ctx context.Context, arg DeleteTaskParams) error {
	_, err := q.db.Exec(ctx, deleteTask, arg.ID, arg.UserID)
	return err
}

const getAgingQuickWins = `-- name: GetAgingQuickWins :many
SELECT id, user_id, title, description, status, user_priority,
       due_date, estimated_effort, category, context, related_people,
       priority_score, bump_count, created_at, updated_at, completed_at,
       series_id, parent_task_id
FROM tasks
WHERE user_id = $1
  AND estimated_effort = 'small'
  AND status != 'done'
  AND created_at <= NOW() - INTERVAL '1 day' * $2
ORDER BY created_at ASC
LIMIT $3
`

type GetAgingQuickWinsParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 interface{} `json:"column_2"`
	Limit   int32       `json:"limit"`
}

type GetAgingQuickWinsRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	SeriesID        pgtype.UUID        `json:"series_id"`
	ParentTaskID    pgtype.UUID        `json:"parent_task_id"`
}

// Gets small effort tasks that are aging (quick wins)
func (q *Queries) GetAgingQuickWins(ctx context.Context, arg GetAgingQuickWinsParams) ([]GetAgingQuickWinsRow, error) {
	rows, err := q.db.Query(ctx, getAgingQuickWins, arg.UserID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAgingQuickWinsRow{}
	for rows.Next() {
		var i GetAgingQuickWinsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.UserPriority,
			&i.DueDate,
			&i.EstimatedEffort,
			&i.Category,
			&i.Context,
			&i.RelatedPeople,
			&i.PriorityScore,
			&i.BumpCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.SeriesID,
			&i.ParentTaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAtRiskTasks = `-- name: GetAtRiskTasks :many
SELECT id, user_id, title, description, status, user_priority,
       due_date, estimated_effort, category, context, related_people,
       priority_score, bump_count, created_at, updated_at, completed_at,
       series_id, parent_task_id
FROM tasks
WHERE user_id = $1
  AND (
      bump_count >= 3
      OR (due_date IS NOT NULL AND due_date < NOW() - INTERVAL '3 days')
  )
  AND status != 'done'
ORDER BY priority_score DESC
`

type GetAtRiskTasksRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	SeriesID        pgtype.UUID        `json:"series_id"`
	ParentTaskID    pgtype.UUID        `json:"parent_task_id"`
}

func (q *Queries) GetAtRiskTasks(ctx context.Context, userID pgtype.UUID) ([]GetAtRiskTasksRow, error) {
	rows, err := q.db.Query(ctx, getAtRiskTasks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAtRiskTasksRow{}
	for rows.Next() {
		var i GetAtRiskTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.UserPriority,
			&i.DueDate,
			&i.EstimatedEffort,
			&i.Category,
			&i.Context,
			&i.RelatedPeople,
			&i.PriorityScore,
			&i.BumpCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
			&i.SeriesID,
			&i.ParentTaskID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAverageBumpCount = `-- name: GetAverageBumpCount :one
SELECT COALESCE(AVG(bump_count), 0) as avg_bump_count
FROM tasks
WHERE user_id = $1 AND status != 'done'
`

func (q *Queries) GetAverageBumpCount(ctx context.Context, userID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getAverageBumpCount, userID)
	var avg_bump_count interface{}
	err := row.Scan(&avg_bump_count)
	return avg_bump_count, err
}

const getCategories = `-- name: GetCategories :many
SELECT DISTINCT category
FROM tasks
WHERE user_id = $1 AND category IS NOT NULL
ORDER BY category
`

func (q *Queries) GetCategories(ctx context.Context, userID pgtype.UUID) ([]*string, error) {
	rows, err := q.db.Query(ctx, getCategories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var category *string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryBreakdown = `-- name: GetCategoryBreakdown :many
SELECT
    COALESCE(category, 'Uncategorized') as category,
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE status = 'done') as completed_count
FROM tasks
WHERE user_id = $1
  AND created_at >= NOW() - INTERVAL '1 day' * $2
GROUP BY category
ORDER BY total_count DESC
`

type GetCategoryBreakdownParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 interface{} `json:"column_2"`
}

type GetCategoryBreakdownRow struct {
	Category       string `json:"category"`
	TotalCount     int64  `json:"total_count"`
	CompletedCount int64  `json:"completed_count"`
}

func (q *Queries) GetCategoryBreakdown(ctx context.Context, arg GetCategoryBreakdownParams) ([]GetCategoryBreakdownRow, error) {
	rows, err := q.db.Query(ctx, getCategoryBreakdown, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryBreakdownRow{}
	for rows.Next() {
		var i GetCategoryBreakdownRow
		if err := rows.Scan(&i.Category, &i.TotalCount, &i.CompletedCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryBumpStats = `-- name: GetCategoryBumpStats :many

SELECT
    COALESCE(category, 'Uncategorized') as category,
    AVG(bump_count)::float as avg_bumps,
    COUNT(*)::int as task_count
FROM tasks
WHERE user_id = $1 AND status != 'done'
GROUP BY category
HAVING AVG(bump_count) > 1
ORDER BY avg_bumps DESC
`

type GetCategoryBumpStatsRow struct {
	Category  string  `json:"category"`
	AvgBumps  float64 `json:"avg_bumps"`
	TaskCount int32   `json:"task_count"`
}

// Insights analytics queries
// Gets average bump count per category for detecting avoidance patterns
func (q *Queries) GetCategoryBumpStats(ctx context.Context, userID pgtype.UUID) ([]GetCategoryBumpStatsRow, error) {
	rows, err := q.db.Query(ctx, getCategoryBumpStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryBumpStatsRow{}
	for rows.Next() {
		var i GetCategoryBumpStatsRow
		if err := rows.Scan(&i.Category, &i.AvgBumps, &i.TaskCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryDistribution = `-- name: GetCategoryDistribution :many
SELECT
    COALESCE(category, 'Uncategorized') as category,
    COUNT(*)::int as task_count,
    (COUNT(*)::float / NULLIF(SUM(COUNT(*)) OVER (), 0) * 100)::float as percentage
FROM tasks
WHERE user_id = $1 AND status != 'done'
GROUP BY category
ORDER BY task_count DESC
`

type GetCategoryDistributionRow struct {
	Category   string  `json:"category"`
	TaskCount  int32   `json:"task_count"`
	Percentage float64 `json:"percentage"`
}

// Gets distribution of pending tasks by category for overload detection
func (q *Queries) GetCategoryDistribution(ctx context.Context, userID pgtype.UUID) ([]GetCategoryDistributionRow, error) {
	rows, err := q.db.Query(ctx, getCategoryDistribution, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryDistributionRow{}
	for rows.Next() {
		var i GetCategoryDistributionRow
		if err := rows.Scan(&i.Category, &i.TaskCount, &i.Percentage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryTrends = `-- name: GetCategoryTrends :many
SELECT
    DATE_TRUNC('week', completed_at)::date as week_start,
    COALESCE(category, 'Uncategorized') as category,
    COUNT(*)::int as count
FROM tasks
WHERE user_id = $1
  AND status = 'done'
  AND completed_at IS NOT NULL
  AND completed_at >= NOW() - ($2::int || ' days')::interval
GROUP BY week_start, category
ORDER BY week_start, category
`

type GetCategoryTrendsParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 int32       `json:"column_2"`
}

type GetCategoryTrendsRow struct {
	WeekStart pgtype.Date `json:"week_start"`
	Category  string      `json:"category"`
	Count     int32       `json:"count"`
}

// Gets weekly task completion counts by category for trend visualization
func (q *Queries) GetCategoryTrends(ctx context.Context, arg GetCategoryTrendsParams) ([]GetCategoryTrendsRow, error) {
	rows, err := q.db.Query(ctx, getCategoryTrends, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryTrendsRow{}
	for rows.Next() {
		var i GetCategoryTrendsRow
		if err := rows.Scan(&i.WeekStart, &i.Category, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletionByDayOfWeek = `-- name: GetCompletionByDayOfWeek :many
SELECT
    EXTRACT(DOW FROM completed_at)::int as day_of_week,
    COUNT(*)::int as completed_count
FROM tasks
WHERE user_id = $1
  AND status = 'done'
  AND completed_at >= NOW() - INTERVAL '1 day' * $2
GROUP BY day_of_week
ORDER BY completed_count DESC
`

type GetCompletionByDayOfWeekParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 interface{} `json:"column_2"`
}

type GetCompletionByDayOfWeekRow struct {
	DayOfWeek      int32 `json:"day_of_week"`
	CompletedCount int32 `json:"completed_count"`
}

// Gets task completions grouped by day of week for peak performance detection
func (q *Queries) GetCompletionByDayOfWeek(ctx context.Context, arg GetCompletionByDayOfWeekParams) ([]GetCompletionByDayOfWeekRow, error) {
	rows, err := q.db.Query(ctx, getCompletionByDayOfWeek, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCompletionByDayOfWeekRow{}
	for rows.Next() {
		var i GetCompletionByDayOfWeekRow
		if err := rows.Scan(&i.DayOfWeek, &i.CompletedCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletionStats = `-- name: GetCompletionStats :one

SELECT
    COUNT(*) as total_tasks,
    COUNT(*) FILTER (WHERE status = 'done') as completed_tasks,
    COUNT(*) FILTER (WHERE status != 'done') as pending_tasks
FROM tasks
WHERE user_id = $1
  AND created_at >= NOW() - INTERVAL '1 day' * $2
`

type GetCompletionStatsParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 interface{} `json:"column_2"`
}

type GetCompletionStatsRow struct {
	TotalTasks     int64 `json:"total_tasks"`
	CompletedTasks int64 `json:"completed_tasks"`
	PendingTasks   int64 `json:"pending_tasks"`
}

// Analytics queries
func (q *Queries) GetCompletionStats(ctx context.Context, arg GetCompletionStatsParams) (GetCompletionStatsRow, error) {
	row := q.db.QueryRow(ctx, getCompletionStats, arg.UserID, arg.Column2)
	var i GetCompletionStatsRow
	err := row.Scan(&i.TotalTasks, &i.CompletedTasks, &i.PendingTasks)
	return i, err
}

const getCompletionTimeStats = `-- name: GetCompletionTimeStats :one
SELECT
    COUNT(*)::int as sample_size,
    COALESCE(PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY
        EXTRACT(EPOCH FROM (completed_at - created_at)) / 86400
    ), 0)::float as median_days,
    COALESCE(AVG(EXTRACT(EPOCH FROM (completed_at - created_at)) / 86400), 0)::float as avg_days
FROM tasks
WHERE user_id = $1
  AND status = 'done'
  AND completed_at IS NOT NULL
  AND ($2::text IS NULL OR category = $2)
  AND ($3::task_effort IS NULL OR estimated_effort = $3)
`

type GetCompletionTimeStatsParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 string      `json:"column_2"`
	Column3 TaskEffort  `json:"column_3"`
}

type GetCompletionTimeStatsRow struct {
	SampleSize int32   `json:"sample_size"`
	MedianDays float64 `json:"median_days"`
	AvgDays    float64 `json:"avg_days"`
}

// Gets completion time statistics for time estimation
func (q *Queries) GetCompletionTimeStats(ctx context.Context, arg GetCompletionTimeStatsParams) (GetCompletionTimeStatsRow, error) {
	row := q.db.QueryRow(ctx, getCompletionTimeStats, arg.UserID, arg.Column2, arg.Column3)
	var i GetCompletionTimeStatsRow
	err := row.Scan(&i.SampleSize, &i.MedianDays, &i.AvgDays)
	return i, err
}

const getDeadlineClusters = `-- name: GetDeadlineClusters :many
SELECT
    DATE(due_date) as due_date,
    COUNT(*)::int as task_count,
    array_agg(title) as titles
FROM tasks
WHERE user_id = $1
  AND status != 'done'
  AND due_date IS NOT NULL
  AND due_date >= NOW()
  AND due_date <= NOW() + INTERVAL '1 day' * $2
GROUP BY DATE(due_date)
HAVING COUNT(*) >= 3
ORDER BY due_date
`

type GetDeadlineClustersParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 interface{} `json:"column_2"`
}

type GetDeadlineClustersRow struct {
	DueDate   pgtype.Date `json:"due_date"`
	TaskCount int32       `json:"task_count"`
	Titles    interface{} `json:"titles"`
}

// Gets dates with multiple tasks due (deadline clustering)
func (q *Queries) GetDeadlineClusters(ctx context.Context, arg GetDeadlineClustersParams) ([]GetDeadlineClustersRow, error) {
	rows, err := q.db.Query(ctx, getDeadlineClusters, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDeadlineClustersRow{}
	for rows.Next() {
		var i GetDeadlineClustersRow
		if err := rows.Scan(&i.DueDate, &i.TaskCount, &i.Titles); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPriorityDistribution = `-- name: GetPriorityDistribution :many
SELECT
    CASE
        WHEN priority_score >= 90 THEN 'Critical (90-100)'
        WHEN priority_score >= 75 THEN 'High (75-89)'
        WHEN priority_score >= 50 THEN 'Medium (50-74)'
        ELSE 'Low (0-49)'
    END as priority_range,
    COUNT(*) as task_count
FROM tasks
WHERE user_id = $1 AND status != 'done'
GROUP BY
    CASE
        WHEN priority_score >= 90 THEN 'Critical (90-100)'
        WHEN priority_score >= 75 THEN 'High (75-89)'
        WHEN priority_score >= 50 THEN 'Medium (50-74)'
        ELSE 'Low (0-49)'
    END
ORDER BY
    MIN(
        CASE
            WHEN priority_score >= 90 THEN 1
            WHEN priority_score >= 75 THEN 2
            WHEN priority_score >= 50 THEN 3
            ELSE 4
        END
    )
`

type GetPriorityDistributionRow struct {
	PriorityRange string `json:"priority_range"`
	TaskCount     int64  `json:"task_count"`
}

func (q *Queries) GetPriorityDistribution(ctx context.Context, userID pgtype.UUID) ([]GetPriorityDistributionRow, error) {
	rows, err := q.db.Query(ctx, getPriorityDistribution, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPriorityDistributionRow{}
	for rows.Next() {
		var i GetPriorityDistributionRow
		if err := rows.Scan(&i.PriorityRange, &i.TaskCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductivityHeatmap = `-- name: GetProductivityHeatmap :many
SELECT
    EXTRACT(DOW FROM completed_at)::int as day_of_week,
    EXTRACT(HOUR FROM completed_at)::int as hour,
    COUNT(*)::int as count
FROM tasks
WHERE user_id = $1
  AND status = 'done'
  AND completed_at IS NOT NULL
  AND completed_at >= NOW() - ($2::int || ' days')::interval
GROUP BY day_of_week, hour
ORDER BY day_of_week, hour
`

type GetProductivityHeatmapParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 int32       `json:"column_2"`
}

type GetProductivityHeatmapRow struct {
	DayOfWeek int32 `json:"day_of_week"`
	Hour      int32 `json:"hour"`
	Count     int32 `json:"count"`
}

// Gets completion counts by day of week and hour for heatmap visualization
func (q *Queries) GetProductivityHeatmap(ctx context.Context, arg GetProductivityHeatmapParams) ([]GetProductivityHeatmapRow, error) {
	rows, err := q.db.Query(ctx, getProductivityHeatmap, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductivityHeatmapRow{}
	for rows.Next() {
		var i GetProductivityHeatmapRow
		if err := rows.Scan(&i.DayOfWeek, &i.Hour, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, user_id, title, description, status, user_priority,
       due_date, estimated_effort, category, context, related_people,
       priority_score, bump_count, created_at, updated_at, completed_at,
       series_id, parent_task_id
FROM tasks
WHERE id = $1 AND deleted_at IS NULL
`

type GetTaskByIDRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	SeriesID        pgtype.UUID        `json:"series_id"`
	ParentTaskID    pgtype.UUID        `json:"parent_task_id"`
}

func (q *Queries) GetTaskByID(ctx context.Context, id pgtype.UUID) (GetTaskByIDRow, error) {
	row := q.db.QueryRow(ctx, getTaskByID, id)
	var i GetTaskByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.UserPriority,
		&i.DueDate,
		&i.EstimatedEffort,
		&i.Category,
		&i.Context,
		&i.RelatedPeople,
		&i.PriorityScore,
		&i.BumpCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
		&i.SeriesID,
		&i.ParentTaskID,
	)
	return i, err
}

const getTasksByBumpCount = `-- name: GetTasksByBumpCount :many
SELECT bump_count, COUNT(*) as task_count
FROM tasks
WHERE user_id = $1 AND status != 'done'
GROUP BY bump_count
ORDER BY bump_count
`

type GetTasksByBumpCountRow struct {
	BumpCount int32 `json:"bump_count"`
	TaskCount int64 `json:"task_count"`
}

func (q *Queries) GetTasksByBumpCount(ctx context.Context, userID pgtype.UUID) ([]GetTasksByBumpCountRow, error) {
	rows, err := q.db.Query(ctx, getTasksByBumpCount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTasksByBumpCountRow{}
	for rows.Next() {
		var i GetTasksByBumpCountRow
		if err := rows.Scan(&i.BumpCount, &i.TaskCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVelocityMetrics = `-- name: GetVelocityMetrics :many
SELECT
    DATE(completed_at) as completion_date,
    COUNT(*) as completed_count
FROM tasks
WHERE user_id = $1
  AND status = 'done'
  AND completed_at >= NOW() - INTERVAL '1 day' * $2
GROUP BY DATE(completed_at)
ORDER BY completion_date
`

type GetVelocityMetricsParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 interface{} `json:"column_2"`
}

type GetVelocityMetricsRow struct {
	CompletionDate pgtype.Date `json:"completion_date"`
	CompletedCount int64       `json:"completed_count"`
}

func (q *Queries) GetVelocityMetrics(ctx context.Context, arg GetVelocityMetricsParams) ([]GetVelocityMetricsRow, error) {
	rows, err := q.db.Query(ctx, getVelocityMetrics, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVelocityMetricsRow{}
	for rows.Next() {
		var i GetVelocityMetricsRow
		if err := rows.Scan(&i.CompletionDate, &i.CompletedCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementBumpCount = `-- name: IncrementBumpCount :exec
UPDATE tasks
SET bump_count = bump_count + 1, updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type IncrementBumpCountParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) IncrementBumpCount(ctx context.Context, arg IncrementBumpCountParams) error {
	_, err := q.db.Exec(ctx, incrementBumpCount, arg.ID, arg.UserID)
	return err
}

const renameCategoryForUser = `-- name: RenameCategoryForUser :exec
UPDATE tasks
SET category = $1, updated_at = NOW()
WHERE user_id = $2 AND category = $3
`

type RenameCategoryForUserParams struct {
	Category   *string     `json:"category"`
	UserID     pgtype.UUID `json:"user_id"`
	Category_2 *string     `json:"category_2"`
}

// Apply to ALL tasks including completed ones - category management should be universal
func (q *Queries) RenameCategoryForUser(ctx context.Context, arg RenameCategoryForUserParams) error {
	_, err := q.db.Exec(ctx, renameCategoryForUser, arg.Category, arg.UserID, arg.Category_2)
	return err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET title = $1, description = $2, status = $3, user_priority = $4,
    due_date = $5, estimated_effort = $6, category = $7, context = $8,
    related_people = $9, priority_score = $10, bump_count = $11,
    updated_at = $12, completed_at = $13
WHERE id = $14 AND user_id = $15
`

type UpdateTaskParams struct {
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.Exec(ctx, updateTask,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.UserPriority,
		arg.DueDate,
		arg.EstimatedEffort,
		arg.Category,
		arg.Context,
		arg.RelatedPeople,
		arg.PriorityScore,
		arg.BumpCount,
		arg.UpdatedAt,
		arg.CompletedAt,
		arg.ID,
		arg.UserID,
	)
	return err
}
