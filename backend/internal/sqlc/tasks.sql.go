// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTask = `-- name: CreateTask :exec

INSERT INTO tasks (
    id, user_id, title, description, status, user_priority,
    due_date, estimated_effort, category, context, related_people,
    priority_score, bump_count, created_at, updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
`

type CreateTaskParams struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

// Task queries for sqlc code generation
func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) error {
	_, err := q.db.Exec(ctx, createTask,
		arg.ID,
		arg.UserID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.UserPriority,
		arg.DueDate,
		arg.EstimatedEffort,
		arg.Category,
		arg.Context,
		arg.RelatedPeople,
		arg.PriorityScore,
		arg.BumpCount,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteCategoryForUser = `-- name: DeleteCategoryForUser :exec
UPDATE tasks
SET category = NULL, updated_at = NOW()
WHERE user_id = $1 AND category = $2 AND status != 'done'
`

type DeleteCategoryForUserParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	Category *string     `json:"category"`
}

func (q *Queries) DeleteCategoryForUser(ctx context.Context, arg DeleteCategoryForUserParams) error {
	_, err := q.db.Exec(ctx, deleteCategoryForUser, arg.UserID, arg.Category)
	return err
}

const deleteTask = `-- name: DeleteTask :exec
DELETE FROM tasks WHERE id = $1 AND user_id = $2
`

type DeleteTaskParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteTask(ctx context.Context, arg DeleteTaskParams) error {
	_, err := q.db.Exec(ctx, deleteTask, arg.ID, arg.UserID)
	return err
}

const getAtRiskTasks = `-- name: GetAtRiskTasks :many
SELECT id, user_id, title, description, status, user_priority,
       due_date, estimated_effort, category, context, related_people,
       priority_score, bump_count, created_at, updated_at, completed_at
FROM tasks
WHERE user_id = $1
  AND (
      bump_count >= 3
      OR (due_date IS NOT NULL AND due_date < NOW() - INTERVAL '3 days')
  )
  AND status != 'done'
ORDER BY priority_score DESC
`

type GetAtRiskTasksRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetAtRiskTasks(ctx context.Context, userID pgtype.UUID) ([]GetAtRiskTasksRow, error) {
	rows, err := q.db.Query(ctx, getAtRiskTasks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAtRiskTasksRow{}
	for rows.Next() {
		var i GetAtRiskTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.UserPriority,
			&i.DueDate,
			&i.EstimatedEffort,
			&i.Category,
			&i.Context,
			&i.RelatedPeople,
			&i.PriorityScore,
			&i.BumpCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAverageBumpCount = `-- name: GetAverageBumpCount :one
SELECT COALESCE(AVG(bump_count), 0) as avg_bump_count
FROM tasks
WHERE user_id = $1 AND status != 'done'
`

func (q *Queries) GetAverageBumpCount(ctx context.Context, userID pgtype.UUID) (interface{}, error) {
	row := q.db.QueryRow(ctx, getAverageBumpCount, userID)
	var avg_bump_count interface{}
	err := row.Scan(&avg_bump_count)
	return avg_bump_count, err
}

const getCategories = `-- name: GetCategories :many
SELECT DISTINCT category
FROM tasks
WHERE user_id = $1 AND category IS NOT NULL
ORDER BY category
`

func (q *Queries) GetCategories(ctx context.Context, userID pgtype.UUID) ([]*string, error) {
	rows, err := q.db.Query(ctx, getCategories, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*string{}
	for rows.Next() {
		var category *string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryBreakdown = `-- name: GetCategoryBreakdown :many
SELECT
    COALESCE(category, 'Uncategorized') as category,
    COUNT(*) as total_count,
    COUNT(*) FILTER (WHERE status = 'done') as completed_count
FROM tasks
WHERE user_id = $1
  AND created_at >= NOW() - INTERVAL '1 day' * $2
GROUP BY category
ORDER BY total_count DESC
`

type GetCategoryBreakdownParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 interface{} `json:"column_2"`
}

type GetCategoryBreakdownRow struct {
	Category       string `json:"category"`
	TotalCount     int64  `json:"total_count"`
	CompletedCount int64  `json:"completed_count"`
}

func (q *Queries) GetCategoryBreakdown(ctx context.Context, arg GetCategoryBreakdownParams) ([]GetCategoryBreakdownRow, error) {
	rows, err := q.db.Query(ctx, getCategoryBreakdown, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCategoryBreakdownRow{}
	for rows.Next() {
		var i GetCategoryBreakdownRow
		if err := rows.Scan(&i.Category, &i.TotalCount, &i.CompletedCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCompletionStats = `-- name: GetCompletionStats :one

SELECT
    COUNT(*) as total_tasks,
    COUNT(*) FILTER (WHERE status = 'done') as completed_tasks,
    COUNT(*) FILTER (WHERE status != 'done') as pending_tasks
FROM tasks
WHERE user_id = $1
  AND created_at >= NOW() - INTERVAL '1 day' * $2
`

type GetCompletionStatsParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 interface{} `json:"column_2"`
}

type GetCompletionStatsRow struct {
	TotalTasks     int64 `json:"total_tasks"`
	CompletedTasks int64 `json:"completed_tasks"`
	PendingTasks   int64 `json:"pending_tasks"`
}

// Analytics queries
func (q *Queries) GetCompletionStats(ctx context.Context, arg GetCompletionStatsParams) (GetCompletionStatsRow, error) {
	row := q.db.QueryRow(ctx, getCompletionStats, arg.UserID, arg.Column2)
	var i GetCompletionStatsRow
	err := row.Scan(&i.TotalTasks, &i.CompletedTasks, &i.PendingTasks)
	return i, err
}

const getPriorityDistribution = `-- name: GetPriorityDistribution :many
SELECT
    CASE
        WHEN priority_score >= 90 THEN 'Critical (90-100)'
        WHEN priority_score >= 75 THEN 'High (75-89)'
        WHEN priority_score >= 50 THEN 'Medium (50-74)'
        ELSE 'Low (0-49)'
    END as priority_range,
    COUNT(*) as task_count
FROM tasks
WHERE user_id = $1 AND status != 'done'
GROUP BY
    CASE
        WHEN priority_score >= 90 THEN 'Critical (90-100)'
        WHEN priority_score >= 75 THEN 'High (75-89)'
        WHEN priority_score >= 50 THEN 'Medium (50-74)'
        ELSE 'Low (0-49)'
    END
ORDER BY
    MIN(
        CASE
            WHEN priority_score >= 90 THEN 1
            WHEN priority_score >= 75 THEN 2
            WHEN priority_score >= 50 THEN 3
            ELSE 4
        END
    )
`

type GetPriorityDistributionRow struct {
	PriorityRange string `json:"priority_range"`
	TaskCount     int64  `json:"task_count"`
}

func (q *Queries) GetPriorityDistribution(ctx context.Context, userID pgtype.UUID) ([]GetPriorityDistributionRow, error) {
	rows, err := q.db.Query(ctx, getPriorityDistribution, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPriorityDistributionRow{}
	for rows.Next() {
		var i GetPriorityDistributionRow
		if err := rows.Scan(&i.PriorityRange, &i.TaskCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT id, user_id, title, description, status, user_priority,
       due_date, estimated_effort, category, context, related_people,
       priority_score, bump_count, created_at, updated_at, completed_at
FROM tasks
WHERE id = $1
`

type GetTaskByIDRow struct {
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
}

func (q *Queries) GetTaskByID(ctx context.Context, id pgtype.UUID) (GetTaskByIDRow, error) {
	row := q.db.QueryRow(ctx, getTaskByID, id)
	var i GetTaskByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.UserPriority,
		&i.DueDate,
		&i.EstimatedEffort,
		&i.Category,
		&i.Context,
		&i.RelatedPeople,
		&i.PriorityScore,
		&i.BumpCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const getTasksByBumpCount = `-- name: GetTasksByBumpCount :many
SELECT bump_count, COUNT(*) as task_count
FROM tasks
WHERE user_id = $1 AND status != 'done'
GROUP BY bump_count
ORDER BY bump_count
`

type GetTasksByBumpCountRow struct {
	BumpCount int32 `json:"bump_count"`
	TaskCount int64 `json:"task_count"`
}

func (q *Queries) GetTasksByBumpCount(ctx context.Context, userID pgtype.UUID) ([]GetTasksByBumpCountRow, error) {
	rows, err := q.db.Query(ctx, getTasksByBumpCount, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTasksByBumpCountRow{}
	for rows.Next() {
		var i GetTasksByBumpCountRow
		if err := rows.Scan(&i.BumpCount, &i.TaskCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVelocityMetrics = `-- name: GetVelocityMetrics :many
SELECT
    DATE(completed_at) as completion_date,
    COUNT(*) as completed_count
FROM tasks
WHERE user_id = $1
  AND status = 'done'
  AND completed_at >= NOW() - INTERVAL '1 day' * $2
GROUP BY DATE(completed_at)
ORDER BY completion_date
`

type GetVelocityMetricsParams struct {
	UserID  pgtype.UUID `json:"user_id"`
	Column2 interface{} `json:"column_2"`
}

type GetVelocityMetricsRow struct {
	CompletionDate pgtype.Date `json:"completion_date"`
	CompletedCount int64       `json:"completed_count"`
}

func (q *Queries) GetVelocityMetrics(ctx context.Context, arg GetVelocityMetricsParams) ([]GetVelocityMetricsRow, error) {
	rows, err := q.db.Query(ctx, getVelocityMetrics, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetVelocityMetricsRow{}
	for rows.Next() {
		var i GetVelocityMetricsRow
		if err := rows.Scan(&i.CompletionDate, &i.CompletedCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incrementBumpCount = `-- name: IncrementBumpCount :exec
UPDATE tasks
SET bump_count = bump_count + 1, updated_at = NOW()
WHERE id = $1 AND user_id = $2
`

type IncrementBumpCountParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) IncrementBumpCount(ctx context.Context, arg IncrementBumpCountParams) error {
	_, err := q.db.Exec(ctx, incrementBumpCount, arg.ID, arg.UserID)
	return err
}

const renameCategoryForUser = `-- name: RenameCategoryForUser :exec
UPDATE tasks
SET category = $1, updated_at = NOW()
WHERE user_id = $2 AND category = $3 AND status != 'done'
`

type RenameCategoryForUserParams struct {
	Category   *string     `json:"category"`
	UserID     pgtype.UUID `json:"user_id"`
	Category_2 *string     `json:"category_2"`
}

func (q *Queries) RenameCategoryForUser(ctx context.Context, arg RenameCategoryForUserParams) error {
	_, err := q.db.Exec(ctx, renameCategoryForUser, arg.Category, arg.UserID, arg.Category_2)
	return err
}

const updateTask = `-- name: UpdateTask :exec
UPDATE tasks
SET title = $1, description = $2, status = $3, user_priority = $4,
    due_date = $5, estimated_effort = $6, category = $7, context = $8,
    related_people = $9, priority_score = $10, bump_count = $11,
    updated_at = $12, completed_at = $13
WHERE id = $14 AND user_id = $15
`

type UpdateTaskParams struct {
	Title           string             `json:"title"`
	Description     *string            `json:"description"`
	Status          TaskStatus         `json:"status"`
	UserPriority    int32              `json:"user_priority"`
	DueDate         pgtype.Timestamptz `json:"due_date"`
	EstimatedEffort NullTaskEffort     `json:"estimated_effort"`
	Category        *string            `json:"category"`
	Context         *string            `json:"context"`
	RelatedPeople   []string           `json:"related_people"`
	PriorityScore   int32              `json:"priority_score"`
	BumpCount       int32              `json:"bump_count"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	CompletedAt     pgtype.Timestamptz `json:"completed_at"`
	ID              pgtype.UUID        `json:"id"`
	UserID          pgtype.UUID        `json:"user_id"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) error {
	_, err := q.db.Exec(ctx, updateTask,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.UserPriority,
		arg.DueDate,
		arg.EstimatedEffort,
		arg.Category,
		arg.Context,
		arg.RelatedPeople,
		arg.PriorityScore,
		arg.BumpCount,
		arg.UpdatedAt,
		arg.CompletedAt,
		arg.ID,
		arg.UserID,
	)
	return err
}
