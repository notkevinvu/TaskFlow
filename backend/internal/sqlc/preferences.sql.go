// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: preferences.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAllCategoryPreferences = `-- name: DeleteAllCategoryPreferences :exec
DELETE FROM category_preferences WHERE user_id = $1
`

func (q *Queries) DeleteAllCategoryPreferences(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllCategoryPreferences, userID)
	return err
}

const deleteCategoryPreference = `-- name: DeleteCategoryPreference :exec
DELETE FROM category_preferences
WHERE user_id = $1 AND category = $2
`

type DeleteCategoryPreferenceParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	Category string      `json:"category"`
}

func (q *Queries) DeleteCategoryPreference(ctx context.Context, arg DeleteCategoryPreferenceParams) error {
	_, err := q.db.Exec(ctx, deleteCategoryPreference, arg.UserID, arg.Category)
	return err
}

const deleteUserPreferences = `-- name: DeleteUserPreferences :exec
DELETE FROM user_preferences WHERE user_id = $1
`

func (q *Queries) DeleteUserPreferences(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteUserPreferences, userID)
	return err
}

const getCategoryPreference = `-- name: GetCategoryPreference :one
SELECT id, user_id, category, due_date_calculation, created_at, updated_at
FROM category_preferences
WHERE user_id = $1 AND category = $2
`

type GetCategoryPreferenceParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	Category string      `json:"category"`
}

func (q *Queries) GetCategoryPreference(ctx context.Context, arg GetCategoryPreferenceParams) (CategoryPreference, error) {
	row := q.db.QueryRow(ctx, getCategoryPreference, arg.UserID, arg.Category)
	var i CategoryPreference
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Category,
		&i.DueDateCalculation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCategoryPreferencesByUserID = `-- name: GetCategoryPreferencesByUserID :many
SELECT id, user_id, category, due_date_calculation, created_at, updated_at
FROM category_preferences
WHERE user_id = $1
ORDER BY category ASC
`

func (q *Queries) GetCategoryPreferencesByUserID(ctx context.Context, userID pgtype.UUID) ([]CategoryPreference, error) {
	rows, err := q.db.Query(ctx, getCategoryPreferencesByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CategoryPreference{}
	for rows.Next() {
		var i CategoryPreference
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Category,
			&i.DueDateCalculation,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPreferences = `-- name: GetUserPreferences :one
SELECT user_id, default_due_date_calculation, created_at, updated_at
FROM user_preferences
WHERE user_id = $1
`

func (q *Queries) GetUserPreferences(ctx context.Context, userID pgtype.UUID) (UserPreference, error) {
	row := q.db.QueryRow(ctx, getUserPreferences, userID)
	var i UserPreference
	err := row.Scan(
		&i.UserID,
		&i.DefaultDueDateCalculation,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertCategoryPreference = `-- name: UpsertCategoryPreference :exec
INSERT INTO category_preferences (id, user_id, category, due_date_calculation, created_at, updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
ON CONFLICT (user_id, category) DO UPDATE
SET due_date_calculation = EXCLUDED.due_date_calculation,
    updated_at = NOW()
`

type UpsertCategoryPreferenceParams struct {
	ID                 pgtype.UUID        `json:"id"`
	UserID             pgtype.UUID        `json:"user_id"`
	Category           string             `json:"category"`
	DueDateCalculation DueDateCalculation `json:"due_date_calculation"`
}

func (q *Queries) UpsertCategoryPreference(ctx context.Context, arg UpsertCategoryPreferenceParams) error {
	_, err := q.db.Exec(ctx, upsertCategoryPreference,
		arg.ID,
		arg.UserID,
		arg.Category,
		arg.DueDateCalculation,
	)
	return err
}

const upsertUserPreferences = `-- name: UpsertUserPreferences :exec
INSERT INTO user_preferences (user_id, default_due_date_calculation, created_at, updated_at)
VALUES ($1, $2, NOW(), NOW())
ON CONFLICT (user_id) DO UPDATE
SET default_due_date_calculation = EXCLUDED.default_due_date_calculation,
    updated_at = NOW()
`

type UpsertUserPreferencesParams struct {
	UserID                    pgtype.UUID        `json:"user_id"`
	DefaultDueDateCalculation DueDateCalculation `json:"default_due_date_calculation"`
}

func (q *Queries) UpsertUserPreferences(ctx context.Context, arg UpsertUserPreferencesParams) error {
	_, err := q.db.Exec(ctx, upsertUserPreferences, arg.UserID, arg.DefaultDueDateCalculation)
	return err
}
