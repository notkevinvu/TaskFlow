// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dependencies.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addDependency = `-- name: AddDependency :exec
INSERT INTO task_dependencies (task_id, blocked_by_id, created_at)
VALUES ($1, $2, $3)
`

type AddDependencyParams struct {
	TaskID      pgtype.UUID        `json:"task_id"`
	BlockedByID pgtype.UUID        `json:"blocked_by_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

// Add a new dependency relationship
func (q *Queries) AddDependency(ctx context.Context, arg AddDependencyParams) error {
	_, err := q.db.Exec(ctx, addDependency, arg.TaskID, arg.BlockedByID, arg.CreatedAt)
	return err
}

const checkDependencyExists = `-- name: CheckDependencyExists :one
SELECT EXISTS(
    SELECT 1 FROM task_dependencies
    WHERE task_id = $1 AND blocked_by_id = $2
)::bool
`

type CheckDependencyExistsParams struct {
	TaskID      pgtype.UUID `json:"task_id"`
	BlockedByID pgtype.UUID `json:"blocked_by_id"`
}

// Check if a specific dependency exists
func (q *Queries) CheckDependencyExists(ctx context.Context, arg CheckDependencyExistsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkDependencyExists, arg.TaskID, arg.BlockedByID)
	var column_1 bool
	err := row.Scan(&column_1)
	return column_1, err
}

const countIncompleteBlockers = `-- name: CountIncompleteBlockers :one
SELECT COUNT(*)::int
FROM task_dependencies td
INNER JOIN tasks t ON t.id = td.blocked_by_id
WHERE td.task_id = $1
  AND t.status != 'done'
`

// Count incomplete blockers for a single task
func (q *Queries) CountIncompleteBlockers(ctx context.Context, taskID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, countIncompleteBlockers, taskID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countIncompleteBlockersBatch = `-- name: CountIncompleteBlockersBatch :many
SELECT td.task_id, COUNT(*)::int as incomplete_count
FROM task_dependencies td
INNER JOIN tasks t ON t.id = td.blocked_by_id
WHERE td.task_id = ANY($1::uuid[])
  AND t.status != 'done'
GROUP BY td.task_id
`

type CountIncompleteBlockersBatchRow struct {
	TaskID          pgtype.UUID `json:"task_id"`
	IncompleteCount int32       `json:"incomplete_count"`
}

// Batch query: count incomplete blockers for multiple tasks at once
// Key optimization from PR #77 - eliminates N+1 query pattern
func (q *Queries) CountIncompleteBlockersBatch(ctx context.Context, dollar_1 []pgtype.UUID) ([]CountIncompleteBlockersBatchRow, error) {
	rows, err := q.db.Query(ctx, countIncompleteBlockersBatch, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountIncompleteBlockersBatchRow{}
	for rows.Next() {
		var i CountIncompleteBlockersBatchRow
		if err := rows.Scan(&i.TaskID, &i.IncompleteCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockerIDs = `-- name: GetBlockerIDs :many
SELECT blocked_by_id FROM task_dependencies
WHERE task_id = $1
`

// Get just the blocker task IDs (for cycle detection)
func (q *Queries) GetBlockerIDs(ctx context.Context, taskID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getBlockerIDs, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var blocked_by_id pgtype.UUID
		if err := rows.Scan(&blocked_by_id); err != nil {
			return nil, err
		}
		items = append(items, blocked_by_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockerTasks = `-- name: GetBlockerTasks :many
SELECT t.id, t.title, t.status, td.created_at
FROM task_dependencies td
INNER JOIN tasks t ON t.id = td.blocked_by_id
WHERE td.task_id = $1
ORDER BY td.created_at ASC
`

type GetBlockerTasksRow struct {
	ID        pgtype.UUID        `json:"id"`
	Title     string             `json:"title"`
	Status    TaskStatus         `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Get all tasks that block the given task (with task details)
func (q *Queries) GetBlockerTasks(ctx context.Context, taskID pgtype.UUID) ([]GetBlockerTasksRow, error) {
	rows, err := q.db.Query(ctx, getBlockerTasks, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBlockerTasksRow{}
	for rows.Next() {
		var i GetBlockerTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBlockingTasks = `-- name: GetBlockingTasks :many
SELECT t.id, t.title, t.status, td.created_at
FROM task_dependencies td
INNER JOIN tasks t ON t.id = td.task_id
WHERE td.blocked_by_id = $1
ORDER BY td.created_at ASC
`

type GetBlockingTasksRow struct {
	ID        pgtype.UUID        `json:"id"`
	Title     string             `json:"title"`
	Status    TaskStatus         `json:"status"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

// Get all tasks that are blocked by the given task (with task details)
func (q *Queries) GetBlockingTasks(ctx context.Context, blockedByID pgtype.UUID) ([]GetBlockingTasksRow, error) {
	rows, err := q.db.Query(ctx, getBlockingTasks, blockedByID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetBlockingTasksRow{}
	for rows.Next() {
		var i GetBlockingTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDependencyGraph = `-- name: GetDependencyGraph :many
SELECT td.task_id, td.blocked_by_id
FROM task_dependencies td
INNER JOIN tasks t ON t.id = td.task_id
WHERE t.user_id = $1
`

type GetDependencyGraphRow struct {
	TaskID      pgtype.UUID `json:"task_id"`
	BlockedByID pgtype.UUID `json:"blocked_by_id"`
}

// Get all dependency relationships for a user's tasks
func (q *Queries) GetDependencyGraph(ctx context.Context, userID pgtype.UUID) ([]GetDependencyGraphRow, error) {
	rows, err := q.db.Query(ctx, getDependencyGraph, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDependencyGraphRow{}
	for rows.Next() {
		var i GetDependencyGraphRow
		if err := rows.Scan(&i.TaskID, &i.BlockedByID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTasksBlockedByTask = `-- name: GetTasksBlockedByTask :many
SELECT task_id FROM task_dependencies
WHERE blocked_by_id = $1
`

// Get task IDs that are blocked by the given task
func (q *Queries) GetTasksBlockedByTask(ctx context.Context, blockedByID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getTasksBlockedByTask, blockedByID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var task_id pgtype.UUID
		if err := rows.Scan(&task_id); err != nil {
			return nil, err
		}
		items = append(items, task_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeDependency = `-- name: RemoveDependency :execrows
DELETE FROM task_dependencies td
USING tasks t
WHERE td.task_id = $1
  AND td.blocked_by_id = $2
  AND t.id = td.task_id
  AND t.user_id = $3
`

type RemoveDependencyParams struct {
	TaskID      pgtype.UUID `json:"task_id"`
	BlockedByID pgtype.UUID `json:"blocked_by_id"`
	UserID      pgtype.UUID `json:"user_id"`
}

// Remove a dependency (verifies user owns the task)
func (q *Queries) RemoveDependency(ctx context.Context, arg RemoveDependencyParams) (int64, error) {
	result, err := q.db.Exec(ctx, removeDependency, arg.TaskID, arg.BlockedByID, arg.UserID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const verifyTasksExistForUser = `-- name: VerifyTasksExistForUser :one

SELECT COUNT(*)::int FROM tasks
WHERE id IN ($1, $2) AND user_id = $3
`

type VerifyTasksExistForUserParams struct {
	ID     pgtype.UUID `json:"id"`
	ID_2   pgtype.UUID `json:"id_2"`
	UserID pgtype.UUID `json:"user_id"`
}

// Dependency queries for sqlc code generation
// Verify both tasks exist and belong to the user (returns count, should be 2)
func (q *Queries) VerifyTasksExistForUser(ctx context.Context, arg VerifyTasksExistForUserParams) (int32, error) {
	row := q.db.QueryRow(ctx, verifyTasksExistForUser, arg.ID, arg.ID_2, arg.UserID)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}
